---           
layout: post
title: Rails, Circular Logic and Incremental Big Bang Architecture
updated: 2015-02-20 02:16:00 SGT
tags: [tumblr, rails, ruby on rails, architecture, rant]
categories: [not yet categorised]
comments: true
fullview: false
---

Rails is a _fantastic_ solution to a well-understood class of problem: the CRUD-oriented (or REST-oriented) query/report/update Web application, circa 2004-2006. Its philosophy of [curation over configuration](http://gilesbowkett.blogspot.sg/2013/02/the-lie-of-convention-over-configuration.html), despite having been likened to the report-producing languages of old (such as [IBM RPG II](https://en.wikipedia.org/wiki/IBM_RPG_II), means that you really only have two things to worry about: your domain business logic and page transitions (which is another way of saying “your domain business logic, as it applies to presentation”).

And yet, the farther your app gets from that sweet spot„ either by decoupling the UI and using a fancy JavaScript framework; by needing to support user inputs _other than_ typing into form fields and clicking buttons; or even the distance imposed by being nearly ten years on from the “sweet spot” and so many tools and other bits of code have changed around it &mdash; the _harder_ it gets to do what you want to do in The Rails Way. Lots of people much smarter than me, from [Robert C “Uncle Bob” Martin](http://blog.8thlight.com/uncle-bob/archive.html) to [Jim Weirich](https://duckduckgo.com/?q=Jim+Weirich) to [Sandi Metz](http://www.sandimetz.com) to [Matt Wynne](http://blog.mattwynne.net/tag/rails/) and a _host_ of others, have spent many person-months thinking about, grappling with and writing about how to _mitigate_ Rails, the knots it ties you into and the practices that much of the rest of our craft has built consensus on as being essential for good practice, that you _can’t_ use in Rails without superhuman effort. Because the apps we’re building now, even the relatively simple ones, _aren’t_ largely analogous to Basecamp (the application from which Rails was originally extracted).

So here’s the problem I’m facing, and the problem you’ve more than likely faced if you’ve done a non-trivial app in Rails.

If you’ve done any medium-to-large-scale development in other systems, especially in a decent OO language, one of your high priorities is going to be separating your domain logic from your “infrastructure” logic, including layering your presentational logic related to your data models separately from the data models themselves. Small is beautiful, and Ruby has some great tools to let you do that, including in particular the whole universe of [Gems](http://rubygems.org). Rails, however, makes it _bloody hard_ to build what the rest of the craft would view as _modular_ apps that follow [SOLID](https://en.wikipedia.org/wiki/SOLID) principles. The retort to that is generally along the lines of “ [Rails is omakase](http://david.heinemeierhansson.com/2012/rails-is-omakase.html)" — which is _fine_ as long as your app is living within that circa 2004-2006 sweet spot I mentioned earlier. The clock in the upper-right corner of my display here informs me that today is Saturday 7 June _2014_ as I write this. Oops.

So we have great ideas like [Hexagonal](https://www.youtube.com/watch?v=CGN4RFkhH2M) [Rails](http://pivotallabs.com/hexagonal-rails-and-the-ludicrous-terminal-application/) , [_Architecture: The Lost Years_](https://www.youtube.com/watch?v=WpkDN78P884) and so on, that showed ways, with varying degrees of universality, to “get a handle on” the application/system you were developing.

But, can you answer [what your application does](http://youtu.be/CGN4RFkhH2M?t=10m14s)? Not “what is its data model”, “what are the different types of users and permissions”, but a pithy sentence or two that gets across the idea of what makes _your_ application different than every other CRUDtastic app out there, Rails or otherwise. Because if you can’t, none of this Rails-survival lore will help you.

And, equally importantly, as Jim Weirich points out in his Cincy.rb talk [*Decoupling from Rails*](http://youtu.be/tg5RFeSfBM4), is the question of “has this ever been successfully done before? If so, how? If not, what’s been the stumbling block that we have to stand back and work around using something else?” Because, in all fairness to Uncle Bob, if there aren’t examples of his built-on-Rails architecture in the wild for people to poke at, projector-ware can be inspirational but not terribly practical. For instance, as Jim points out at about 10 minutes into his presentation, Uncle Bob’s architecture shows where Rails controllers and views go, but ActiveRecord “models” don’t seem to be there _at all_. Separating domain logic from persistence just happens to be one of the hardest nuts to crack in a Rails app to begin with. Hmmm.

Is the solution more decoupling? Jim spends the rest of that talk isolating and extracting what [several](http://collectiveidea.com/blog/archives/2012/06/28/wheres-your-business-logic/) [teams](http://devblog.orgsync.com/2014/01/23/confidently-manage-business-logic-activeinteraction/) [publish](http://eng.joingrouper.com/blog/2014/03/03/rails-the-missing-parts-interactors) as “interactors”, or support for what I call in my own apps “domain service objects” or DSOs. These help, a _lot_; having “skinny” controllers that don’t really know anything at all about your app beyond how to hand data off to classes that _do_ lets you refactor your business rules efficiently by putting their _control logic_ all in one place _separate_ from Rails. Similarly, implementing façades or “decorators” with presentational logic around your models, as with [Draper](https://github.com/drapergem/draper) and others, helps you write clean, business-logic-free view templates.

But you’ve still got ActiveRecord to deal with in your models, and it leads you down the garden path and over the cliff with things like, oh, _relations_. When you have, say, a `Blog` model that `has_many :posts` and a `Post` model that `belongs_to :blog`, what you’ve got is a circular dependency; you can’t make changes to your `Posts` with certainty that those changes are isolated from your `Blog`, or vice versa, because each depends on the other. There have been numerous serious attempts to effect such a decoupling; perhaps the most widely known is [Ruby Object Manager](http://rom-rb.org), whose Version 2 has been in the works for over _two years now_. It’s led by one of the greats in the Ruby community, [Piotr Solnica](http://solnic.eu), but it’s a _Hard Problem_. Especially when coexisting with Rails. People even resort to uncomfortable hacks [like this](https://gist.github.com/jdickey/e2ed1bbe0c3e6ad3269d) to Get Things Done. There _has_ to be a better way, and monorail (traditional Rails all-in-one non-modular app) is _not_ that way.

And there are other, seemingly orthogonal issues to deal with. Authentication? Authorisation? Several solutions that are widely used exist for these in the “traditional” Rails “monorail” application style; how will adapting your architecture affect these, and how will you implement them?

Anybody?
